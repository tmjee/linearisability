# How it works

## The BIG Idea
The idea is such that we can create our own tests set, bundled everything in a jar file, with a `MANIFEST.MF`
indicating a special Main-Class. If we compile the tests set before bundling it into a jar with `linearisation-core.jar`
in the classpath, the `AnnotationProcessor` in `linearisation-core.jar` will kicked in an find all the linearisation
tests (through annotation processing) and generate
- all necessary `Runner` extension java file and compile them with other assets altogether
- xml file containing all linearisation tests information
and bundled them in a jar file, ready to be executed.

so if we do
```
    $> java -cp linearisation-core.jar:my-linearisation-test.jar -jar mylinearisation-test.jar
```
we will run all the linearisation tests in `my-linearisation-test.jar` and produce a summary for each linearisation
tests.


## The processor, generating Runners (to run tests) and linearisation tests metat-data xml
When we do a compilation with `linearisation-core.jar` in the classpath, we will kick start the annotation processing
feature in `linearisation-core.jar` that starts generating linearisation tests for all clases annotated with
`@linearisable` annotation. It will generate `Runner` class to represent each linearisation tests (
inner class annotated with `@TestUnit` inside an outer class annotated with `@Linearsiation`). It will also generate
a `/META-INF/linearisation_tests.xml` containing information about all the linearisation tests


## The running linearisation tests

- It starts with `Main` which ask `Linearisation` to `run()`
- All tests are read from `/META-INF/linearisation_tests.xml` (which is created by `AnnotationProcessor`)
- `Linearisation` has a `Scheduler` and a `ThreadPoolExecutor` aka `pool`.
- `Scheduler` runs `Sheduler.Task` that runs each `@Player`'s test method off a thread loan from `pool`.
- `Sheduler` will schedule a `Sheduler.Task` to be executed, depending on `-userCpu` argument given (default to 10).
If the number of `Scheduler.Task` submitted is more than `-userCpu`, then the excessive one will be put on wait until
the number of active `Scheduler.Task` drops.
- `SchedulerTask` will run a runner (one that extends off `Runner` and is generated by annotation processor) for
a test (indicated by inner class annotated with `@TestUnit`)
- `Runner` will submit a number of `Worker` (extends from `BaseWorker` also generated by `AnnotationProcessor`)
depends on how many `@Player` methods are annotated in `@TestUnit`.
- `Runner` will submit each `Worker` to the `pool` to run in parallel.
- Regarding running the `Worker`, followings are the steps of the `Worker` run method / procedure
    - Wait for all `Worker` to reach a barrier before continuing
    - `Worker`s will then run test method in parallel
    - `Worker`s will then reach another barrier wating for all `Worker`s to finish runing the test method for a number
times (in a loop). We'll call this stride. A stride is pre-cacluated before running
    - `Worker` will then try to accumulate the result of all strides in an `Accumulator`
    - One `Worker` will then recalculat ethe stride and `Control` that all `Worker` will use in preparation for the next
run of test methods in this particular stride.
    - A barrier also exists waiting for restride and control refresh to be done before proceeding.
    - This stride-and-run-test-method loop goes on until the `Scheduler` decides that the time for test run
(configured through `-time` is up, this is when a volatile flag will be set  and all `Worker` will attempt to exit).
- Each `Scheduler.Task` will be responsible for a test, submitting possibly a number piece of work to `Worker`s.
Before they ends, they also print out the result


