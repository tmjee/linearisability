# How it works

## The BIG Idea
The idea is such that we can create our own tests set, bundled everything in a jar file, with a `MANIFEST.MF`
indicating a special Main-Class. If we compile the tests set before bundling it into a jar with `linearisation-core.jar`
in the classpath, the `AnnotationProcessor` in `linearisation-core.jar` will kicked in an find all the linearisation
tests (through annotation processing) and generate
- all necessary `Runner` extension java file and compile them with other assets altogether
- xml file containing all linearisation tests information
and bundled them in a jar file, ready to be executed.

so if we do
```
    $> java -cp linearisation-core.jar:my-linearisation-test.jar -jar mylinearisation-test.jar
```
we will run all the linearisation tests in `my-linearisation-test.jar` and produce a summary for each linearisation
tests.


## The processor, generating Runners (to run tests) and linearisation tests metat-data xml
When we do a compilation with `linearisation-core.jar` in the classpath, we will kick start the annotation processing
feature in `linearisation-core.jar` that starts generating linearisation tests for all clases annotated with
`@linearisable` annotation. It will generate `Runner` class to represent each linearisation tests (
inner class annotated with `@TestUnit` inside an outer class annotated with `@Linearsiation`). It will also generate
a `/META-INF/linearisation_tests.xml` containing information about all the linearisation tests


## The running linearisation tests

- It starts with `Main` which ask `Linearisation` to `run()`
- All tests are read from `/META-INF/linearisation_tests.xml` (which is created by `AnnotationProcessor`)
- `Linearisation` has a `Scheduler` and a `ThreadPoolExecutor` aka `pool`.
- `Scheduler` runs `Sheduler.Task` that runs each `@Player`'s test method off a thread loan from `pool`.
- `Sheduler` will schedule a `Sheduler.Task` to be executed, depending on `-userCpu` argument given (default to 10).
If the number of `Scheduler.Task` submitted is more than `-userCpu`, then the excessive one will be put on wait until
the number of active `Scheduler.Task` drops.
- `SchedulerTask` will run a runner (one that extends off `Runner` and is generated by annotation processor) for
a test (indicated by inner class annotated with `@TestUnit`)
- `Runner` will submit a number of `Worker` (extends from `BaseWorker` also generated by `AnnotationProcessor`)
depends on how many `@Player` methods are annotated in `@TestUnit`.
- `Runner` will submit each `Worker` to the `pool` to run in parallel.
- Regarding running the `Worker`, followings are the steps of the `Worker` run method / procedure
    - Wait for all `Worker` to reach a barrier before continuing
    - `Worker`s will then run test method in parallel
    - `Worker`s will then reach another barrier wating for all `Worker`s to finish runing the test method for a number
times (in a loop). We'll call this stride. A stride is pre-cacluated before running
    - `Worker` will then try to accumulate the result of all strides in an `Accumulator`
    - One `Worker` will then recalculat ethe stride and `Control` that all `Worker` will use in preparation for the next
run of test methods in this particular stride.
    - A barrier also exists waiting for restride and control refresh to be done before proceeding.
    - This stride-and-run-test-method loop goes on until the `Scheduler` decides that the time for test run
(configured through `-time` is up, this is when a volatile flag will be set  and all `Worker` will attempt to exit).
- Each `Scheduler.Task` will be responsible for a test, submitting possibly a number piece of work to `Worker`s.
Before they ends, they also print out the result


## E.g.

Typical example of testing the count of two concurrent 'put' into a Map would be as follows:

```java
@Consequence(
  id = "[1]", 
  expectation = Expectation.ACCEPTABLE, 
  description = "Running count for player 1 and 2 match expected result")
@Consequence(
  id = "[-1]", 
  expectation = Expectation.FORBIDDEN, 
  description = "Running count for player 1 and 2 do not match expected result")
@Reference(
  "https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md")
public class TestMetaInfo {
}

Figure 12: Code sample for a typical linearisation test meta data.
```

```java
@Linearisable
@Meta(TestMetaInfo.class)
public class LinearisationTestForTotalCount {

    @Invariant
    public static class State {
        final Map<Integer,Integer> m = new LockBasedFriendlyTreeMap<>();
    }

    @TestUnit(name="LinearisationTestForTotalCount")
    public static class TestUnit1 {
        @Player public void player1(State s, IntResult1 r) {
            try {
                Map<Integer, Integer> m = state.get();
                for (int a = 0; a < 100; a++) {
                    m.put(a, a);
                }
            }catch(Exception e) {
                System.out.println("Player 1 experience exception");
                e.printStackTrace();
            }
        }
        @Player public void player2(State s, IntResult1 r) {
            try {
                Map<Integer, Integer> m = state.get();
                for (int b = 100; b < 300; b++) {
                    m.put(b, b);
                }
            } catch(Exception e) {
                System.out.println("Player 2 experience exception", e);
                e.printStackTrace();
            }
        }
        @Arbiter public void arbiter(State s, IntResult1 r) { 
            Map<Integer, Integer> m = state.get();
            int size = m.size();
            r.value1 = ((size == 300)?1:-1);
        }
    }
}

Figure 13: Code sample of a linearisation test.
```

This would trigger the following scheduler execution pattern (refer to runner execution pattern) :-
```
                                    Start
                                      |
                                      | Scheduler (Z)
                                      v
                                      |
             +---------------+--------+---------+---------------+
             |               |                  |               |
 Runner1 (Y) |   Runner2 (X) |   Runner N-1 (W) |  Runner N (V) |
             V               V                  V               V
             |               |                  |               |
             +---------------+--------+---------+---------------+
                                      |
                                      |
                                      V  Wait for all Runners to end (U)
                                      |
                                      |
                                  Terminate
                                  
 Figure 14: Flow chart of tests execution, excluding details of runner.
```

| Symbol    | Description  |
| --------- | ------------ |
|  Z        |  - Scheduler creates a thread for each test. Each test is run by a runner.  
|           |  - Number of runner at a time depends on configuration option (-userCpu)
|           |  - Probably want -userCpu to equals to number of cores (as tests we are running
|           |  cpu intensive
|  Y,Z,W,V  |  - Individual tests ran by a runner thread (concurrently)
|  U        |  Scheduler wait for all runner to end before terminating

Table 9: Description of symbols used in Figure 14.




``` 
                        |
                        +--------------------------------<-------------+
                        |                                              |
                        | runner (A)                                   |
                        +                                              |  
                        |                                              |
                        V                                              |
                  +-----+------+                                       |
                  |            |                                       |
     player1 (B)  |            | player2 (C)                           |
                  +------------+                                       |
                        |                                              |
                        |                                              |
                        +------------------<----------+                |
                        |                             |                |
                        | barrier (D)                 |                |
                        |                             |                |
                        V                             |                |
                  +-----+-------+                     |                |
     player1 (E)  |             | player2 (F)         | Stride (K)     | Iteration (L)
                  V             V                     |                |
                  +-------------+                     |                |
                        |                             ^                ^
                        | barrier (G)                 |                |
                        V                             |                |
                  +-----+-------+                     |                |
    player1 (H)   |             | player2 (I)         |                |
                  V             V                     |                |
                  +-------------+                     |                |
                        |                             |                |
                        | barrier (J)                 |                |
                        V                             |                |
                        |                             |                |
                   timeout yet?                       |                |
                        |                             |                |
                        ^                             |                |
                       / \  (M)                       |                |
                      <   >------>---- NO-------------+                |
                       \ /                                             |
                        v                                              |
                        |                                              |
                       YES                                             |
                        |                                              |
                        |                                              |
                Done all iteration?                                    |
                        |                                              |
                        ^                                              |
                       / \  (N)                                        |
                      <   >------>---- NO------------------------------+
                       \ /
                        v
                        |
                       YES
                        |
                      
Figure 15: Flow chart of tests execution, expanding details of runner only. 
```


| Symbol  | Description  |
| ------- | ------------ |
|  A      | Runner runs a test, getting a thread from pool to act as each @Player
|  B      | @Player 1 thread spawned by Runner
|  C      | @Player 2 thread spawned by Runner
|  D      | Barrier that wait for all @Player(s) to be ready
|  E      | @Player 1 runs his test method
|  F      | @Player 2 runs his test  
|  G      | Barrier that wait for all @Player(s) to finish their respective test
|  H,I    | Either @Player 1 or @Player 2 but not both (depends on who gets the epoch atomically) will :-
|         |   - run the @Aribiter
|         |   - accumulate result from each stride
|         |   - prepare for next stride (eg. reset the @Record)
|         |   - reset control (immutable) so no control interference with other stides
|  J      | Barrier that waits for both @Player(s) to be ready 
|  K      | Strides loop
|  L      | Iteration loop
|  M      | If timeout (specified by -time) end the stride
|  N      | If done with iteration (specified by -iteration) end the test

Table 10: Descriptions of symbols used in Figure 15.
