
<#assign testClassClassName=test.testClass().className()>
<#assign testClassPackageName=test.testClass().packageName()>
<#assign runnerClassName=test.runner().className()>
<#assign runnerPackageName=test.runner().packageName()>
<#assign invariantClassName=test.invariant().className()>
<#assign invariantPackageName=test.invariant().packageName()>
<#assign recordClassName=test.record().className()>
<#assign recordPackageName=test.record().packageName()>
<#assign testMethods=test.testMethods()>

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overriden.
 */
package ${runnerPackageName};

import com.tmjee.linearisation.processor.Arguments;
import com.tmjee.linearisation.processor.Control;
import com.tmjee.linearisation.processor.Runner;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import ${testClassPackageName}.*;
<#if invariantPackageName != testClassPackageName>
import ${invariantPackageName}.*;
</#if>
<#if recordPackageName != testClassClassName>
import ${recordPackageName}.*;
</#if>
<#if runnerPackageName != testClassClassName>
import ${runnerPackageName}.*;
</#if>

public class ${runnerClassName} extends Runner {

    public ${runnerClassName}(Arguments args, ExecutorService pool) {
        super(args, pool);
    }
<#--
        ${test.testClass().className()} test = new ${test.testClass().className()}();
        ${test.invariant().className()} invariant = new ${test.invariant().className()}();
        ${test.record().className()} record = new ${test.record().className()}();
-->
    protected void internalRun() {
        ${testClassClassName} test = new ${testClassClassName}();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ${invariantClassName}(),
                new ${recordClassName}());
        }

        Holder holder = new Holder(new AtomicReferenceArray<>(p));

        Control control = new Control(2);
        control.setRunning(true);

        AtomicInteger epoch = new AtomicInteger();
        List<Future> tasks = new ArrayList<>();
        tasks.add(pool.submit(() -> {
            new Runner1(control, args, test, new AtomicReference<Holder>(holder), epoch).run();
                return null;
            }));
        tasks.add(pool.submit(()->{
            new Runner2(control, args, test, new AtomicReference<Holder>(holder), epoch).run();
                    return null;
            }));
        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        control.setRunning(false);
        waitFor(tasks);
    }




    private static abstract class BaseRunner {

        protected final Control control;
        protected final Arguments args;
        protected final ${testClassClassName} test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;

        public BaseRunner(Control control, Arguments args, ${testClassClassName} test, AtomicReference<Holder> holderRef, AtomicInteger epoch) {
             this.control = control;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
        }

        protected void restride() {
            // TODO: record stats

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ${invariantClassName}(),
                    new ${recordClassName}());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;
            while(true) {
                Holder holder = holderRef.get();
                if (!control.isRunning()) {
                   return;
                }

                AtomicReferenceArray<Pair> pRef = holder.getPair();
                int pSize = pRef.length();

                control.getWaitForStartBarrier().await();

                for (int a = 0; a < pSize; a++) {
                    Pair p = pRef.get(a);

                    runPlayerAction(p);
                }

                control.getWaitForDoneBarrier().await();

                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    restride();
                }
                currentEpoch++;

                control.getWaitForRestrideBarrier().await();

                if (firstToIncrementEpoch) {
                    control.resetBarriers();
                }
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    <#list testMethods as testMethod>
    <#assign counter=testMethod?counter>
    private static class Runner${counter} extends BaseRunner {
        public Runner${counter}(Control control, Arguments args, ${testClassClassName} test, AtomicReference<Holder> holderRef,
            AtomicInteger epoch) {
            super(control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.${testMethod.methodName()}(p.s, p.r);
        }
    }
    </#list>



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ${invariantClassName} s;
        private final ${recordClassName} r;

        public Pair(LinearisabilityTest.State s, LinearisabilityTest.Result r) {
            this.s = s;
            this.r = r;
        }
    }
}
