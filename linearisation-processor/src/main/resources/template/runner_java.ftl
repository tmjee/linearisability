<#assign testClassClassName=test.testClass().className()>
<#assign testClassPackageName=test.testClass().packageName()>
<#assign runnerClassName=test.runner().className()>
<#assign runnerPackageName=test.runner().packageName()>
<#assign invariantClassName=test.invariant().className()>
<#assign invariantPackageName=test.invariant().packageName()>
<#assign recordClassName=test.record().className()>
<#assign recordPackageName=test.record().packageName()>
<#assign testMethods=test.testMethods()>
<#assign testMethodsCount=test.testsCount()>

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package ${runnerPackageName};

import com.tmjee.linearisation.processor.Arguments;
import com.tmjee.linearisation.processor.Control;
import com.tmjee.linearisation.processor.Runner;
import com.tmjee.linearisation.processor.TestResultWriter;
import com.tmjee.linearisation.processor.Accumulator;
import com.tmjee.linearisation.processor.State;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import ${testClassPackageName}.*;
<#if (invariantPackageName != testClassPackageName)>
import ${invariantPackageName}.*;
</#if>
<#if (recordPackageName != testClassPackageName)>
import ${recordPackageName}.*;
</#if>
<#if (runnerPackageName != testClassPackageName)>
import ${runnerPackageName}.*;
</#if>

public class ${runnerClassName} extends Runner {

    public ${runnerClassName}(Arguments args, ExecutorService pool, TestResultWriter writer) {
        super(args, pool, writer);
    }

    protected void internalRun() {
        ${testClassClassName} test = new ${testClassClassName}();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ${invariantClassName}(),
                new ${recordClassName}());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(${testMethodsCount}));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        <#list testMethods as testMethod>
            <#assign counter=testMethod?counter>
            tasks.add(pool.submit(() -> {
                new Worker${counter}(state, control, args, test, holder, epoch, writer).run();
                return null;
            }));
        </#list>

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
    }


    private static abstract class BaseWorker {

        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ${testClassClassName} test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final TestResultWriter writer;
        protected final State state;

        public BaseWorker(State state, AtomicReference<Control> controlRef, Arguments args, ${testClassClassName} test, AtomicReference<Holder> holderRef,
                AtomicInteger epoch, TestResultWriter writer) {
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.writer = writer;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ${invariantClassName}(),
                    new ${recordClassName}());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;
            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();

                AtomicReferenceArray<Pair> pRef = holder.getPair();
                int pSize = pRef.length();

                control.waitForStart();

                if ((!state.running) || Thread.currentThread().isInterrupted() ) {
                    System.out.println(Thread.currentThread()+" exit stride");
                    return;
                }

                for (int a = 0; a < pSize; a++) {
                    Pair p = pRef.get(a);

                    runPlayerAction(p);
                }

                control.waitForDone();

                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    restride();
                    resetControl();
                }
                currentEpoch++;

                Accumulator acc = new Accumulator();
                for (int a=0; a< pSize; a++) {
                    Pair p = pRef.get(a);
                    acc.record(p.r.toString());
                }
                writer.writeTestResult(acc);


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    <#list testMethods as testMethod>
    <#assign counter=testMethod?counter>
    private static class Worker${counter} extends BaseWorker {
        public Worker${counter}(State state, AtomicReference<Control> control, Arguments args, ${testClassClassName} test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch, TestResultWriter writer) {
            super(state, control, args, test, holderRef, epoch, writer);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.${testMethod.methodName()}(p.s, p.r);
        }
    }
    </#list>



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ${invariantClassName} s;
        private final ${recordClassName} r;

        public Pair(LinearisabilityTest.State s, LinearisabilityTest.Result r) {
            this.s = s;
            this.r = r;
        }
    }
}
