[INFO] Scanning for projects...
[WARNING] 
[WARNING] Some problems were encountered while building the effective model for com.tmjee.linearisation:linearisation-core:jar:1.0-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-enforcer-plugin is missing. @ com.tmjee.linearisation:linearisation-core:[unknown-version], /home/tmjee/private/repos/linearisation/linearisation-core/pom.xml, line 58, column 21
[WARNING] 
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING] 
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING] 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO] 
[INFO] linearisation-parent
[INFO] linearisation-core
[INFO] linearisation-sample
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building linearisation-parent 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ linearisation-parent ---
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ linearisation-parent ---
[INFO] Installing /home/tmjee/private/repos/linearisation/pom.xml to /home/tmjee/.m2/repository/com/tmjee/linearisation/linearisation-parent/1.0-SNAPSHOT/linearisation-parent-1.0-SNAPSHOT.pom
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building linearisation-core 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ linearisation-core ---
[INFO] Deleting /home/tmjee/private/repos/linearisation/linearisation-core/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ linearisation-core ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 3 resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ linearisation-core ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 36 source files to /home/tmjee/private/repos/linearisation/linearisation-core/target/classes
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-core/src/main/java/com/tmjee/linearisation/processor/AnnotationProcessor.java: /home/tmjee/private/repos/linearisation/linearisation-core/src/main/java/com/tmjee/linearisation/processor/AnnotationProcessor.java uses unchecked or unsafe operations.
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-core/src/main/java/com/tmjee/linearisation/processor/AnnotationProcessor.java: Recompile with -Xlint:unchecked for details.
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ linearisation-core ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ linearisation-core ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to /home/tmjee/private/repos/linearisation/linearisation-core/target/test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ linearisation-core ---
[INFO] Surefire report directory: /home/tmjee/private/repos/linearisation/linearisation-core/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.tmjee.linearisation.processor.TestsTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.082 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] 
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ linearisation-core ---
[INFO] Building jar: /home/tmjee/private/repos/linearisation/linearisation-core/target/linearisation-core.jar
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ linearisation-core ---
[INFO] Installing /home/tmjee/private/repos/linearisation/linearisation-core/target/linearisation-core.jar to /home/tmjee/.m2/repository/com/tmjee/linearisation/linearisation-core/1.0-SNAPSHOT/linearisation-core-1.0-SNAPSHOT.jar
[INFO] Installing /home/tmjee/private/repos/linearisation/linearisation-core/pom.xml to /home/tmjee/.m2/repository/com/tmjee/linearisation/linearisation-core/1.0-SNAPSHOT/linearisation-core-1.0-SNAPSHOT.pom
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building linearisation-sample 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ linearisation-sample ---
[INFO] Deleting /home/tmjee/private/repos/linearisation/linearisation-sample/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ linearisation-sample ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ linearisation-sample ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 108 source files to /home/tmjee/private/repos/linearisation/linearisation-sample/target/classes

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class PriorityQueue_OfferAndPoll_Test_TestUnit1_Runner extends Runner {

    public PriorityQueue_OfferAndPoll_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        PriorityQueue_OfferAndPoll_Test.TestUnit1 test = new PriorityQueue_OfferAndPoll_Test.TestUnit1();
        PriorityQueue_OfferAndPoll_Test.State s = new PriorityQueue_OfferAndPoll_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        PriorityQueue_OfferAndPoll_Test.TestUnit1 test = new PriorityQueue_OfferAndPoll_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new PriorityQueue_OfferAndPoll_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final PriorityQueue_OfferAndPoll_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, PriorityQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new PriorityQueue_OfferAndPoll_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, PriorityQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, PriorityQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final PriorityQueue_OfferAndPoll_Test.State s;
        private final IntResult2 r;

        public Pair(PriorityQueue_OfferAndPoll_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingFriendlyHashMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingFriendlyHashMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1();
        SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State s = new SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbier(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingCliffHashMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingCliffHashMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1();
        SbNonBlockingCliffHashMap_PutRunningCount_Test.State s = new SbNonBlockingCliffHashMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingCliffHashMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingCliffHashMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingCliffHashMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingCliffHashMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class HashMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public HashMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        HashMap_BulkPutRemove_Test.TestUnit1 test = new HashMap_BulkPutRemove_Test.TestUnit1();
        HashMap_BulkPutRemove_Test.State s = new HashMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        HashMap_BulkPutRemove_Test.TestUnit1 test = new HashMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new HashMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final HashMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, HashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new HashMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final HashMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(HashMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingFriendlySkipListMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingFriendlySkipListMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1 test = new SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1();
        SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State s = new SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1 test = new SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLogicalOrderingAVL_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public SbLogicalOrderingAVL_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1 test = new SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1();
        SbLogicalOrderingAVL_PutAndGet_Test.State s = new SbLogicalOrderingAVL_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1 test = new SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLogicalOrderingAVL_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLogicalOrderingAVL_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLogicalOrderingAVL_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(SbLogicalOrderingAVL_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class CopyOnWriteArrayList_SetAndGet_Test_TestUnit1_Runner extends Runner {

    public CopyOnWriteArrayList_SetAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        CopyOnWriteArrayList_SetAndGet_Test.TestUnit1 test = new CopyOnWriteArrayList_SetAndGet_Test.TestUnit1();
        CopyOnWriteArrayList_SetAndGet_Test.State s = new CopyOnWriteArrayList_SetAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        CopyOnWriteArrayList_SetAndGet_Test.TestUnit1 test = new CopyOnWriteArrayList_SetAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new CopyOnWriteArrayList_SetAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final CopyOnWriteArrayList_SetAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, CopyOnWriteArrayList_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new CopyOnWriteArrayList_SetAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, CopyOnWriteArrayList_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, CopyOnWriteArrayList_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final CopyOnWriteArrayList_SetAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(CopyOnWriteArrayList_SetAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLogicalOrderingAVL_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbLogicalOrderingAVL_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1 test = new SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1();
        SbLogicalOrderingAVL_BulkPutRemove_Test.State s = new SbLogicalOrderingAVL_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1 test = new SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLogicalOrderingAVL_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLogicalOrderingAVL_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLogicalOrderingAVL_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbLogicalOrderingAVL_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentHashMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public ConcurrentHashMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentHashMap_PutAndGet_Test.TestUnit1 test = new ConcurrentHashMap_PutAndGet_Test.TestUnit1();
        ConcurrentHashMap_PutAndGet_Test.State s = new ConcurrentHashMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentHashMap_PutAndGet_Test.TestUnit1 test = new ConcurrentHashMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentHashMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentHashMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentHashMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentHashMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(ConcurrentHashMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLogicalOrderingAVL_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbLogicalOrderingAVL_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test = new SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1();
        SbLogicalOrderingAVL_PutRunningCount_Test.State s = new SbLogicalOrderingAVL_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test = new SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLogicalOrderingAVL_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLogicalOrderingAVL_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLogicalOrderingAVL_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbLogicalOrderingAVL_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class HashMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public HashMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        HashMap_PutRunningCount_Test.TestUnit1 test = new HashMap_PutRunningCount_Test.TestUnit1();
        HashMap_PutRunningCount_Test.State s = new HashMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        HashMap_PutRunningCount_Test.TestUnit1 test = new HashMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new HashMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final HashMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, HashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new HashMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final HashMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(HashMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentSkipListMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public ConcurrentSkipListMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1 test = new ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1();
        ConcurrentSkipListMap_BulkPutRemove_Test.State s = new ConcurrentSkipListMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1 test = new ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentSkipListMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentSkipListMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentSkipListMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(ConcurrentSkipListMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingFriendlySkipListMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingFriendlySkipListMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1();
        SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State s = new SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingTorontoBSTMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingTorontoBSTMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1();
        SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State s = new SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingFriendlyHashMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingFriendlyHashMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1();
        SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State s = new SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingTorontoBSTMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingTorontoBSTMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1();
        SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State s = new SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test = new SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingCliffHashMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingCliffHashMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1 test = new SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1();
        SbNonBlockingCliffHashMap_PutAndGet_Test.State s = new SbNonBlockingCliffHashMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1 test = new SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingCliffHashMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingCliffHashMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingCliffHashMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(SbNonBlockingCliffHashMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class HashMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public HashMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        HashMap_PutAndGet_Test.TestUnit1 test = new HashMap_PutAndGet_Test.TestUnit1();
        HashMap_PutAndGet_Test.State s = new HashMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        HashMap_PutAndGet_Test.TestUnit1 test = new HashMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new HashMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final HashMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, HashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new HashMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final HashMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(HashMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentSkipListSet_SetAndGet_Test_TestUnit1_Runner extends Runner {

    public ConcurrentSkipListSet_SetAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentSkipListSet_SetAndGet_Test.TestUnit1 test = new ConcurrentSkipListSet_SetAndGet_Test.TestUnit1();
        ConcurrentSkipListSet_SetAndGet_Test.State s = new ConcurrentSkipListSet_SetAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentSkipListSet_SetAndGet_Test.TestUnit1 test = new ConcurrentSkipListSet_SetAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentSkipListSet_SetAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentSkipListSet_SetAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentSkipListSet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentSkipListSet_SetAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListSet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListSet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentSkipListSet_SetAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(ConcurrentSkipListSet_SetAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentHashMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public ConcurrentHashMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentHashMap_PutRunningCount_Test.TestUnit1 test = new ConcurrentHashMap_PutRunningCount_Test.TestUnit1();
        ConcurrentHashMap_PutRunningCount_Test.State s = new ConcurrentHashMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentHashMap_PutRunningCount_Test.TestUnit1 test = new ConcurrentHashMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentHashMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentHashMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentHashMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentHashMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentHashMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(ConcurrentHashMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingCliffHashMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingCliffHashMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1();
        SbNonBlockingCliffHashMap_BulkPutRemove_Test.State s = new SbNonBlockingCliffHashMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingCliffHashMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingCliffHashMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingCliffHashMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingCliffHashMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentLinkedQueue_OfferAndPoll_Test_TestUnit1_Runner extends Runner {

    public ConcurrentLinkedQueue_OfferAndPoll_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1 test = new ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1();
        ConcurrentLinkedQueue_OfferAndPoll_Test.State s = new ConcurrentLinkedQueue_OfferAndPoll_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1 test = new ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentLinkedQueue_OfferAndPoll_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentLinkedQueue_OfferAndPoll_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentLinkedQueue_OfferAndPoll_Test.State s;
        private final IntResult2 r;

        public Pair(ConcurrentLinkedQueue_OfferAndPoll_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLockBasedFriendlyTreeMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbLockBasedFriendlyTreeMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test = new SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1();
        SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State s = new SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test = new SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentSkipListMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public ConcurrentSkipListMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1 test = new ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1();
        ConcurrentSkipListMap_PutRunningCount_Test.State s = new ConcurrentSkipListMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1 test = new ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentSkipListMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentSkipListMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentSkipListMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(ConcurrentSkipListMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1();
        SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State s = new SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test = new SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ArrayList_SetAndGet_Test_TestUnit1_Runner extends Runner {

    public ArrayList_SetAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ArrayList_SetAndGet_Test.TestUnit1 test = new ArrayList_SetAndGet_Test.TestUnit1();
        ArrayList_SetAndGet_Test.State s = new ArrayList_SetAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ArrayList_SetAndGet_Test.TestUnit1 test = new ArrayList_SetAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ArrayList_SetAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ArrayList_SetAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ArrayList_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ArrayList_SetAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ArrayList_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ArrayList_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ArrayList_SetAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(ArrayList_SetAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class HashSet_SetAndGet_Test_TestUnit1_Runner extends Runner {

    public HashSet_SetAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        HashSet_SetAndGet_Test.TestUnit1 test = new HashSet_SetAndGet_Test.TestUnit1();
        HashSet_SetAndGet_Test.State s = new HashSet_SetAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        HashSet_SetAndGet_Test.TestUnit1 test = new HashSet_SetAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new HashSet_SetAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final HashSet_SetAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, HashSet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new HashSet_SetAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashSet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, HashSet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final HashSet_SetAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(HashSet_SetAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ArrayBlockingQueue_OfferAndPoll_Test_TestUnit1_Runner extends Runner {

    public ArrayBlockingQueue_OfferAndPoll_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1 test = new ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1();
        ArrayBlockingQueue_OfferAndPoll_Test.State s = new ArrayBlockingQueue_OfferAndPoll_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1 test = new ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ArrayBlockingQueue_OfferAndPoll_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ArrayBlockingQueue_OfferAndPoll_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ArrayBlockingQueue_OfferAndPoll_Test.State s;
        private final IntResult2 r;

        public Pair(ArrayBlockingQueue_OfferAndPoll_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLockBasedStanfordTreeMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbLockBasedStanfordTreeMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1 test = new SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1();
        SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State s = new SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1 test = new SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentHashMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public ConcurrentHashMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentHashMap_BulkPutRemove_Test.TestUnit1 test = new ConcurrentHashMap_BulkPutRemove_Test.TestUnit1();
        ConcurrentHashMap_BulkPutRemove_Test.State s = new ConcurrentHashMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentHashMap_BulkPutRemove_Test.TestUnit1 test = new ConcurrentHashMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentHashMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentHashMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentHashMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentHashMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentHashMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(ConcurrentHashMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class ConcurrentSkipListMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public ConcurrentSkipListMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        ConcurrentSkipListMap_PutAndGet_Test.TestUnit1 test = new ConcurrentSkipListMap_PutAndGet_Test.TestUnit1();
        ConcurrentSkipListMap_PutAndGet_Test.State s = new ConcurrentSkipListMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        ConcurrentSkipListMap_PutAndGet_Test.TestUnit1 test = new ConcurrentSkipListMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new ConcurrentSkipListMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final ConcurrentSkipListMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, ConcurrentSkipListMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new ConcurrentSkipListMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, ConcurrentSkipListMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final ConcurrentSkipListMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(ConcurrentSkipListMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLockBasedStanfordTreeMap_PutRunningCount_Test_TestUnit1_Runner extends Runner {

    public SbLockBasedStanfordTreeMap_PutRunningCount_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test = new SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1();
        SbLockBasedStanfordTreeMap_PutRunningCount_Test.State s = new SbLockBasedStanfordTreeMap_PutRunningCount_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
        test.arbiter(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test = new SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLockBasedStanfordTreeMap_PutRunningCount_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(3));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker3(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLockBasedStanfordTreeMap_PutRunningCount_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }
    private static class Worker3 extends BaseWorker {
        public Worker3(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.arbiter(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLockBasedStanfordTreeMap_PutRunningCount_Test.State s;
        private final IntResult1 r;

        public Pair(SbLockBasedStanfordTreeMap_PutRunningCount_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbNonBlockingFriendlyHashMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public SbNonBlockingFriendlyHashMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1 test = new SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1();
        SbNonBlockingFriendlyHashMap_PutAndGet_Test.State s = new SbNonBlockingFriendlyHashMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1 test = new SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbNonBlockingFriendlyHashMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbNonBlockingFriendlyHashMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbNonBlockingFriendlyHashMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(SbNonBlockingFriendlyHashMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class CopyOnWriteArraySet_SetAndGet_Test_TestUnit1_Runner extends Runner {

    public CopyOnWriteArraySet_SetAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        CopyOnWriteArraySet_SetAndGet_Test.TestUnit1 test = new CopyOnWriteArraySet_SetAndGet_Test.TestUnit1();
        CopyOnWriteArraySet_SetAndGet_Test.State s = new CopyOnWriteArraySet_SetAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        CopyOnWriteArraySet_SetAndGet_Test.TestUnit1 test = new CopyOnWriteArraySet_SetAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new CopyOnWriteArraySet_SetAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final CopyOnWriteArraySet_SetAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, CopyOnWriteArraySet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new CopyOnWriteArraySet_SetAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, CopyOnWriteArraySet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, CopyOnWriteArraySet_SetAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final CopyOnWriteArraySet_SetAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(CopyOnWriteArraySet_SetAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLockBasedFriendlyTreeMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public SbLockBasedFriendlyTreeMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1 test = new SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1();
        SbLockBasedFriendlyTreeMap_PutAndGet_Test.State s = new SbLockBasedFriendlyTreeMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1 test = new SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLockBasedFriendlyTreeMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLockBasedFriendlyTreeMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLockBasedFriendlyTreeMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(SbLockBasedFriendlyTreeMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class LinkedBlockingQueue_OfferAndPoll_Test_TestUnit1_Runner extends Runner {

    public LinkedBlockingQueue_OfferAndPoll_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1 test = new LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1();
        LinkedBlockingQueue_OfferAndPoll_Test.State s = new LinkedBlockingQueue_OfferAndPoll_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1 test = new LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new LinkedBlockingQueue_OfferAndPoll_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new LinkedBlockingQueue_OfferAndPoll_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final LinkedBlockingQueue_OfferAndPoll_Test.State s;
        private final IntResult2 r;

        public Pair(LinkedBlockingQueue_OfferAndPoll_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLockBasedFriendlyTreeMap_BulkPutRemove_Test_TestUnit1_Runner extends Runner {

    public SbLockBasedFriendlyTreeMap_BulkPutRemove_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1 test = new SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1();
        SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State s = new SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State();
        IntResult1 r = new IntResult1();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1 test = new SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State(),
                new IntResult1());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State(),
                    new IntResult1());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                test.arbiter(p.s,p.r);
            }
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State s;
        private final IntResult1 r;

        public Pair(SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State s, IntResult1 r) {
            this.s = s;
            this.r = r;
        }
    }
}

/**
 * This class is generated by linearisation-processor. Please do not edit
 * as it will be overridden.
 */
package linearisation.generated;

import com.tmjee.linearisation.processor.*;

import static java.lang.String.format;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

import com.tmjee.linearisation.sample.*;
import com.tmjee.linearisation.processor.*;
import linearisation.generated.*;

public class SbLockBasedStanfordTreeMap_PutAndGet_Test_TestUnit1_Runner extends Runner {

    public SbLockBasedStanfordTreeMap_PutAndGet_Test_TestUnit1_Runner(Test test, Arguments args, ExecutorService pool) {
        super(test, args, pool);
    }

    protected void runVerification() throws Throwable{

        SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1 test = new SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1();
        SbLockBasedStanfordTreeMap_PutAndGet_Test.State s = new SbLockBasedStanfordTreeMap_PutAndGet_Test.State();
        IntResult2 r = new IntResult2();


        test.player1(s,r);
        test.player2(s,r);
    }

    protected Accumulator internalRun() {
        Accumulator accumulator = new Accumulator();

        SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1 test = new SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1();

        int strides = args.minStrides();
        Pair[] p = new Pair[strides];
        for (int a =0; a< strides; a++) {
            p[a] = new Pair(
                new SbLockBasedStanfordTreeMap_PutAndGet_Test.State(),
                new IntResult2());
        }

        AtomicReference<Holder> holder = new AtomicReference<>(new Holder(new AtomicReferenceArray<>(p)));
        AtomicReference<Control> control = new AtomicReference<>(new Control(2));
        State state = new State();

        AtomicInteger epoch = new AtomicInteger();

        List<Future<?>> tasks = new ArrayList<>();

        tasks.add(pool.submit(() -> {
            new Worker1(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));
        tasks.add(pool.submit(() -> {
            new Worker2(accumulator, state, control, args, test, holder, epoch).run();
            return null;
        }));

        try {
            Thread.currentThread().sleep(args.time());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        state.running=false;
        waitFor(tasks);
        return accumulator;
    }


    private static abstract class BaseWorker {

        protected final Accumulator accumulator;
        protected final AtomicReference<Control> controlRef;
        protected final Arguments args;
        protected final SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1 test;
        protected final AtomicReference<Holder> holderRef;
        protected final AtomicInteger epoch;
        protected final State state;

        public BaseWorker(Accumulator accumulator, State state, AtomicReference<Control> controlRef,
                        Arguments args, SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                        AtomicInteger epoch) {
             this.accumulator = accumulator;
             this.controlRef = controlRef;
             this.args = args;
             this.test = test;
             this.holderRef = holderRef;
             this.epoch = epoch;
             this.state = state;
        }

        protected void resetControl() {
            controlRef.set(new Control(controlRef.get()));
        }

        protected void restride() {

            Holder holder = holderRef.get();
            AtomicReferenceArray<Pair> pRef = holder.getPair();

            int length = pRef.length();
            int strides = Math.max(args.minStrides(), Math.min(length * 2, args.maxStrides()));

            Pair[] p = new Pair[strides];
            for (int a =0; a< strides; a++) {
                p[a] = new Pair(
                    new SbLockBasedStanfordTreeMap_PutAndGet_Test.State(),
                    new IntResult2());
            }

            holderRef.set(new Holder(new AtomicReferenceArray<>(p)));
        }

        protected void accumulateStrideResult(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a< pSize; a++) {
                Pair p = pRef.get(a);
                accumulator.record(p.r.toString());
            }
        }

        protected void runPlayer(AtomicReferenceArray<Pair> pRef) {
            int pSize = pRef.length();
            for (int a=0; a<pSize; a++) {
                Pair p = pRef.get(a);
                runPlayerAction(p);
            }
        }

        protected void runArbiter(AtomicReferenceArray<Pair> pRef) {
            // content only available when there is an @Arbiter configured
        }

        public void run() throws BrokenBarrierException, InterruptedException {
            boolean firstToIncrementEpoch = false;
            AtomicInteger ep = epoch;
            int currentEpoch = 0;

            while(true) {
                Holder holder = holderRef.get();
                Control control = controlRef.get();
                final boolean running = state.running;

                AtomicReferenceArray<Pair> pRef = holder.getPair();

                control.waitForStart();

                if ((!running)) {
                    Logger.log(format("worker exit "));
                    return;
                }


                runPlayer(pRef);


                control.waitForDone();


                firstToIncrementEpoch = ep.compareAndSet(currentEpoch, currentEpoch + 1);
                if (firstToIncrementEpoch) {
                    runArbiter(pRef);
                    accumulateStrideResult(pRef);
                    restride();
                    resetControl();
                }
                currentEpoch++;


                while (currentEpoch != ep.get()) {
                   Thread.yield();
                }


                control.waitForRestride();
            }
        }

        protected abstract void runPlayerAction(Pair p);
    }


    private static class Worker1 extends BaseWorker {
        public Worker1(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player1(p.s, p.r);
        }
    }
    private static class Worker2 extends BaseWorker {
        public Worker2(Accumulator accumulator, State state, AtomicReference<Control> control,
                                Arguments args, SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1 test, AtomicReference<Holder> holderRef,
                                AtomicInteger epoch) {
            super(accumulator, state, control, args, test, holderRef, epoch);
        }

        @Override
        protected void runPlayerAction(Pair p) {
            test.player2(p.s, p.r);
        }
    }



    private static class Holder {
        AtomicReferenceArray<Pair> pRef;

        Holder(AtomicReferenceArray<Pair> pRef) {
             this.pRef = pRef;
        }

        public AtomicReferenceArray<Pair> getPair() { return pRef; }
    }

    private static class Pair {
        private final SbLockBasedStanfordTreeMap_PutAndGet_Test.State s;
        private final IntResult2 r;

        public Pair(SbLockBasedStanfordTreeMap_PutAndGet_Test.State s, IntResult2 r) {
            this.s = s;
            this.r = r;
        }
    }
}
<?xml version="1.0" encoding="UTF-8"  ?>
<!--
    #
    # Auto generated by linearisation-processor. Do not modify, changes will be overridden.
    #
-->
<linearisation-tests>
      <linearisation-test>
       <name>PriorityQueue_OfferAndPoll_Test</name>
       <description>PriorityQueue Offer and Poll Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>PriorityQueue_OfferAndPoll_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO not observed, size is good</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO observed, size is not good</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>FIFO observed, size is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/queue/OfferAndPoll_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>PriorityQueue_OfferAndPoll_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>PriorityQueue_OfferAndPoll_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingFriendlyHashMap_BulkPutRemove_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbier</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingFriendlyHashMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingFriendlyHashMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingCliffHashMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingCliffHashMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingCliffHashMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingCliffHashMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>HashMap_BulkPutRemove_Test</name>
       <description>HashMap Bulk Put Remove Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>HashMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>HashMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>HashMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingFriendlySkipListMap_PutAndGet_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingFriendlySkipListMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingFriendlySkipListMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingFriendlySkipListMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLogicalOrderingAVL_PutAndGet_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLogicalOrderingAVL_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLogicalOrderingAVL_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLogicalOrderingAVL_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>CopyOnWriteArrayList_SetAndGet_Test</name>
       <description>CopyOnWriteArrayList Set and get test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>CopyOnWriteArrayList_SetAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 and 2 do not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 gets back unexpected result, Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back value inserted, Player 2 get back value inserted</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception, Player 2 get back unexpected value</description>
           </consequence>
           <consequence>
               <id>[-2,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 and 2 thrown exception</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back value inserted, Player 2 did not get back value expected</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Player 1 and 2 got back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/list/SetAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>CopyOnWriteArrayList_SetAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>CopyOnWriteArrayList_SetAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLogicalOrderingAVL_BulkPutRemove_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLogicalOrderingAVL_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLogicalOrderingAVL_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLogicalOrderingAVL_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentHashMap_PutAndGet_Test</name>
       <description>ConcurrentHashMap Put and get Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentHashMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentHashMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentHashMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLogicalOrderingAVL_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLogicalOrderingAVL_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLogicalOrderingAVL_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLogicalOrderingAVL_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>PutRunningCountHashMapTest_TestUnit1</name>
       <description>Put and do running count (unit1)</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>HashMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>HashMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>HashMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentSkipListMap_BulkPutRemove_Test</name>
       <description>ConcurrentSkipListMap Bulk Put Remove Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentSkipListMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentSkipListMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentSkipListMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingFriendlySkipListMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingFriendlySkipListMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingFriendlySkipListMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingTorontoBSTMap_BulkPutRemove_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingTorontoBSTMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingTorontoBSTMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingFriendlyHashMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingFriendlyHashMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingFriendlyHashMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingFriendlyHashMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingTorontoBSTMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingTorontoBSTMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingTorontoBSTMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingTorontoBSTMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingCliffHashMap_PutAndGet_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingCliffHashMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingCliffHashMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingCliffHashMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>PutAndGetHashMap_TestUnit_1</name>
       <description>Put and get hash map (unit1)</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>HashMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>HashMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>HashMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentSkipListSet_SetAndGet_Test</name>
       <description>ConcurrentSkipListSet Set and Get Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentSkipListSet_SetAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not retrieved value added, Player 2 did not retrieved value added</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is incorrect, Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not retrieved value added, Player 2 retrieved value added</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception, Player 2 result is incorrect</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 retrieved value added, Player 2 did not retrieved value added</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Player 1 retrieved value added, Player 2 retrieved value added.</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/set/SetAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentSkipListSet_SetAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentSkipListSet_SetAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentHashMap_PutRunningCount_Test</name>
       <description>ConcurrentHashMap Put Running Count Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentHashMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentHashMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentHashMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingCliffHashMap_BulkPutRemove</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingCliffHashMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingCliffHashMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingCliffHashMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentLinkedQueue_OfferAndPoll_Test</name>
       <description>ConcurrentLinkedQueue Offer and Poll Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentLinkedQueue_OfferAndPoll_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO not observed, size is good</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO observed, size is not good</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>FIFO observed, size is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/queue/OfferAndPoll_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentLinkedQueue_OfferAndPoll_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentLinkedQueue_OfferAndPoll_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLockBasedFriendlyTreeMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLockBasedFriendlyTreeMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLockBasedFriendlyTreeMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLockBasedFriendlyTreeMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentSkipListMap_PutRunningCount_Test</name>
       <description>ConcurrentSkipListMap Put Running Count Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentSkipListMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentSkipListMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentSkipListMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingFriendlySkipListMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SetAndGetArrayListTest_Unit1</name>
       <description>Set and get array list test (unit 1)</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ArrayList_SetAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 and 2 do not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 gets back unexpected result, Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back value inserted, Player 2 get back value inserted</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception, Player 2 get back unexpected value</description>
           </consequence>
           <consequence>
               <id>[-2,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 and 2 thrown exception</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back value inserted, Player 2 did not get back value expected</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Player 1 and 2 got back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/list/SetAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ArrayList_SetAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ArrayList_SetAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SetAndGetHashSetTest_Unit1</name>
       <description>Set and get hashset test (unit 1)</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>HashSet_SetAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not retrieved value added, Player 2 did not retrieved value added</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is incorrect, Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not retrieved value added, Player 2 retrieved value added</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception, Player 2 result is incorrect</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 retrieved value added, Player 2 did not retrieved value added</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Player 1 retrieved value added, Player 2 retrieved value added.</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/set/SetAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>HashSet_SetAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>HashSet_SetAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ArrayBlockingQueue_OfferAndPoll_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ArrayBlockingQueue_OfferAndPoll_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO not observed, size is good</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO observed, size is not good</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>FIFO observed, size is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/queue/OfferAndPoll_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ArrayBlockingQueue_OfferAndPoll_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ArrayBlockingQueue_OfferAndPoll_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLockBasedStanfordTreeMap_BulkPutRemove_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLockBasedStanfordTreeMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLockBasedStanfordTreeMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLockBasedStanfordTreeMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentHashMap_BulkPutRemove_Test</name>
       <description>ConcurrentHashMap Bulk Put Remove Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentHashMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentHashMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentHashMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>ConcurrentSkipListMap_PutAndGet_Test</name>
       <description>ConcurrentSkipListMap Put and Get Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>ConcurrentSkipListMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>ConcurrentSkipListMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>ConcurrentSkipListMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLockBasedStanfordTreeMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLockBasedStanfordTreeMap_PutRunningCount_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>arbiter</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Running count for player 1 and 2 do not match expected result</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Running count for player 1 and 2 match expected result</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutRunningCount_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLockBasedStanfordTreeMap_PutRunningCount_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLockBasedStanfordTreeMap_PutRunningCount_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbNonBlockingFriendlyHashMap_PutRunningCount_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbNonBlockingFriendlyHashMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbNonBlockingFriendlyHashMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbNonBlockingFriendlyHashMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>CopyOnWriteArraySet_SetAndGet_Test</name>
       <description>CopOnWriteArraySet Set and Get Test</description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>CopyOnWriteArraySet_SetAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not retrieved value added, Player 2 did not retrieved value added</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is incorrect, Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not retrieved value added, Player 2 retrieved value added</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception, Player 2 result is incorrect</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 retrieved value added, Player 2 did not retrieved value added</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Player 1 retrieved value added, Player 2 retrieved value added.</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/set/SetAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>CopyOnWriteArraySet_SetAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>CopyOnWriteArraySet_SetAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLockBasedFriendlyTreeMap_PutAndGet_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLockBasedFriendlyTreeMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLockBasedFriendlyTreeMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLockBasedFriendlyTreeMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>LinkedBlockingQueue_OfferAndPoll_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>LinkedBlockingQueue_OfferAndPoll_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO not observed, size is good</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>FIFO observed, size is not good</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>FIFO observed, size is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/queue/OfferAndPoll_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>LinkedBlockingQueue_OfferAndPoll_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>LinkedBlockingQueue_OfferAndPoll_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLockedBasedFriendlyTreeMap_BulkPutRemove_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <arbiterMethod>
           <methodName>arbiter</methodName>
           <arg0>invariant</arg0>
           <arg1>record</arg1>
       </arbiterMethod>
       <consequences>
           <consequence>
               <id>[-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>size after bulk insert and delete is not good</description>
           </consequence>
           <consequence>
               <id>[1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>size after bulk insert and delete is good</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/BulkPutRemove_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLockBasedFriendlyTreeMap_BulkPutRemove_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLockBasedFriendlyTreeMap_BulkPutRemove_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult1</className>
       </record>
   </linearisation-test>
   <linearisation-test>
       <name>SbLockBasedStanfordTreeMap_PutAndGet_Test</name>
       <description></description>
       <testPackageName>com.tmjee.linearisation.sample</testPackageName>
       <testClassName>SbLockBasedStanfordTreeMap_PutAndGet_Test.TestUnit1</testClassName>
       <testMethods>
           <testMethod>
               <methodName>player1</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
           <testMethod>
               <methodName>player2</methodName>
               <arg0>invariant</arg0>
               <arg1>record</arg1>
           </testMethod>
       </testMethods>
       <consequences>
           <consequence>
               <id>[-1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Both player 1 and player 2 did not get back expected value</description>
           </consequence>
           <consequence>
               <id>[-1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 result is unexpected, Player 2 throws exception </description>
           </consequence>
           <consequence>
               <id>[-1,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 did not get back expected value but Player 2 did</description>
           </consequence>
           <consequence>
               <id>[-2,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws Exception, Player 2 results is unexpected</description>
           </consequence>
           <consequence>
               <id>[-2,1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 throws exception</description>
           </consequence>
           <consequence>
               <id>[1,-1]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 1 get back expected value while Player 2 did not</description>
           </consequence>
           <consequence>
               <id>[1,-2]</id>
               <expectation>FORBIDDEN</expectation>
               <description>Player 2 throws Exception</description>
           </consequence>
           <consequence>
               <id>[1,1]</id>
               <expectation>ACCEPTABLE</expectation>
               <description>Both player 1 and 2 get back expected values</description>
           </consequence>
       </consequences>
       <references>
           <reference>https://github.com/tmjee/linearisability/blob/master/docs/results/map/PutAndGet_Test.md</reference>
       </references>
       <runner>
           <packageName>linearisation.generated</packageName>
           <className>SbLockBasedStanfordTreeMap_PutAndGet_Test_TestUnit1_Runner</className>
       </runner>
       <invariant>
           <packageName>com.tmjee.linearisation.sample</packageName>
           <className>SbLockBasedStanfordTreeMap_PutAndGet_Test.State</className>
       </invariant>
       <record>
           <packageName>com.tmjee.linearisation.processor</packageName>
           <className>IntResult2</className>
       </record>
   </linearisation-test>
</linearisation-tests>
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingFriendlyHashMap.java:[7,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[3,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/ConcurrentAutoTable.java:[8,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingCliffHashMap.java:[26,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingFriendlyHashMap.java:[7,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[3,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/ConcurrentAutoTable.java:[8,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingCliffHashMap.java:[26,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingFriendlyHashMap.java:[7,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[3,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/ConcurrentAutoTable.java:[8,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingCliffHashMap.java:[26,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingFriendlyHashMap.java:[7,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[3,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/ConcurrentAutoTable.java:[8,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingCliffHashMap.java:[26,16] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingFriendlyHashMap.java:[82,20] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[18,17] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[21,14] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[23,25] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/UtilUnsafe.java:[25,15] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/cliffutils/ConcurrentAutoTable.java:[120,26] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/hashtables/lockfree/NonBlockingCliffHashMap.java:[106,20] sun.misc.Unsafe is internal proprietary API and may be removed in a future release
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/trees/lockbased/LogicalOrderingAVL.java: Some input files use unchecked or unsafe operations.
[WARNING] /home/tmjee/private/repos/linearisation/linearisation-sample/src/main/java/synchrobench/trees/lockbased/LogicalOrderingAVL.java: Recompile with -Xlint:unchecked for details.
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ linearisation-sample ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /home/tmjee/private/repos/linearisation/linearisation-sample/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ linearisation-sample ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ linearisation-sample ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ linearisation-sample ---
[INFO] Building jar: /home/tmjee/private/repos/linearisation/linearisation-sample/target/linearisation-sample-1.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-shade-plugin:1.7.1:shade (main) @ linearisation-sample ---
[INFO] Including com.tmjee.linearisation:linearisation-core:jar:1.0-SNAPSHOT in the shaded jar.
[INFO] Including net.sf.jopt-simple:jopt-simple:jar:4.9 in the shaded jar.
[INFO] Including org.hdrhistogram:HdrHistogram:jar:2.1.6 in the shaded jar.
[INFO] Including org.freemarker:freemarker:jar:2.3.23 in the shaded jar.
[INFO] Replacing /home/tmjee/private/repos/linearisation/linearisation-sample/target/linearisation-sample.jar with /home/tmjee/private/repos/linearisation/linearisation-sample/target/linearisation-sample-1.0-SNAPSHOT-shaded.jar
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ linearisation-sample ---
[INFO] Installing /home/tmjee/private/repos/linearisation/linearisation-sample/target/linearisation-sample-1.0-SNAPSHOT.jar to /home/tmjee/.m2/repository/com/tmjee/linearisation/linearisation-sample/1.0-SNAPSHOT/linearisation-sample-1.0-SNAPSHOT.jar
[INFO] Installing /home/tmjee/private/repos/linearisation/linearisation-sample/pom.xml to /home/tmjee/.m2/repository/com/tmjee/linearisation/linearisation-sample/1.0-SNAPSHOT/linearisation-sample-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] linearisation-parent ............................... SUCCESS [  0.310 s]
[INFO] linearisation-core ................................. SUCCESS [  2.882 s]
[INFO] linearisation-sample ............................... SUCCESS [  4.330 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 7.622 s
[INFO] Finished at: 2015-08-22T22:21:40+10:00
[INFO] Final Memory: 21M/294M
[INFO] ------------------------------------------------------------------------
